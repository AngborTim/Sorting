<!DOCTYPE HTML>
<html lang="en">
<HTML>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="css/4.6.1_bootstrap.css" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">

    <link href="pics/favicon.ico" rel="icon">
  
    <script src="js/jquery-3.6.0.min.js"></script>
    <script src="js/popper.js"></script>
    <script src="js/bootstrap.js"></script>
    

    <title>Sorting</title>
</head>

<body>


<h1>Sorting</h1>

<div class="container justify-content-center"> 

  <table class="table">
    <tr id="numbers">
    </tr>
    <tr id="buffer">
    </tr>
  </table>
<input id="btn_sort" type="button" class="btn btn-outline-primary btn-block" value="Merge sort">
<input onclick="make_tree(numbers_array)" id="test" type="button" class="btn btn-outline-primary btn-block" value="Create a tree">
<input id="show_tree" type="button" class="btn btn-outline-primary btn-block" value="Show tree">

</div>

</body>

<script>
let count = 5;
let numbers_array = Array.from(Array(count).keys());
let root;

$(document).ready(function() {
  shuffle(Object.assign([],numbers_array));
  new_numbers();
});


$("#show_tree").on('click', () =>{
  if (typeof root != "undefined"){
    root.show();
  }
  else alert("There is no tree")
})

class tree_node {
  constructor(n_array, parent) {
    this.n_array = n_array;
    this.has_children = false;
    this.branch = null;
    this.children = [];
    this.left = null;
    this.right = null;
    if (typeof parent != "undefined" ){
      this.parent = parent;
    }
    else {
      this.parent = null;
    }
    if (this.parent == null){
      this.level = 0;
    }
    else {
      this.level = this.parent.level + 1;
    }
    this.child();
  }
  child() {
    if (this.n_array.length !=1){
      this.has_children = true;
      let m = Math.floor(this.n_array.length / 2);
      let l = this.n_array.slice(0,m);
      let r = this.n_array.slice(m);
      const left = new tree_node(l, this);
      left.branch = "left";
      const right = new tree_node(r,this);
      right.branch = "right";
      this.left = left;
      this.right = right;
      this.children.push(this.left , this.right);

    }
    else return 0
  }
  
  delete(){
    try{
      if (this.has_children) {
        throw "Can't delete. Has children."
      }
      else {
        delete this.n_array;
        delete this.has_children;
        if (this.branch == "left"){
          this.parent.children.shift();
          delete this.parent.left;
        }
        else {
          this.parent.children.pop();
          delete this.parent.right;
        }
        delete this.branch;}
    }
    catch(err){
      console.log("Error: "+err);
    }
  }

  sort(){
    if (this.has_children){
      this.children.forEach(element => {
        return element.sort();
        });
    }
    else {
      if (this.branch == "left" && !this.parent.right.has_children) {
        let tmp=[];
        this.n_array.forEach((element, index) => {
          if (element < this.parent.right.n_array[index]){
            tmp.push(element, this.parent.right.n_array[index]);
          }
          else {
            tmp.push(this.parent.right.n_array[index], element);
          }
          console.log(tmp)
        })
        if (this.n_array.length < this.parent.right.n_array.length){
          for (let i=this.n_array.length-1; i < this.parent.right.n_array.length; i++){
            tmp.push(this.parent.right.n_array[i]);
          }
        }
        else if (this.n_array.length > this.parent.right.n_array.length){
          for (let i=this.parent.right.n_array.length; i < this.n_array.length-1; i++){
            tmp.push(this.n_array[i]);
          }
        }
      }
    }
        // let left = this.n_array[0];
        // let right = this.parent.right.n_array[0]; 
        // this.parent.n_array = [];
        // if (left < right){
        //   this.parent.n_array.push(left, right)
        // }
        // else {
        //   this.parent.n_array.push(right, left)
        // }
        // this.parent.right.delete();
        // this.delete();

      // let z = this.branch;
      // let d;
      // switch (z) {
      //   case "left":
      //     if (this.parent.right.has_children) {
      //       d = " has children";
      //     } 
      //     else {
      //       d = "";
      //     }
      //     console.log("I'm "+z+ " | "+ this.n_array+ "| My sibling: | "+ this.parent.right.n_array +" | "+ this.parent.right.branch+d);
      //     break;
      //   case "right":
      //     if (this.parent.left.has_children) {
      //       d = "has children";
      //     } 
      //     else {
      //       d = "";
      //     }
      //     console.log("I'm "+z+ " | "+ this.n_array+ "| My sibling:  | "+ this.parent.left.n_array +" | "+ this.parent.left.branch+d);
      //     break;
      //   case "null":
      //     console.log("I'm alone and " +z);  
      //     break;
      // }
      return 0;
  }
  
  show(){
    console.log(this.n_array + " | level: " + this.level + " Branch: "+ this.branch);
      if (this.has_children){
        this.children.forEach(element => {
          element.show();
        });
      }
      else {
        return 0;
      }
    }
// CLASS END ===========================
}


// function show_tree(root_node, depth = 0){
//   console.log(root_node.n_array + "| depth: " + depth);
//   if (root_node.descendants.length != 0){
//     root_node.descendants.forEach(element => {
//       show_tree(element, depth +1);
//     });
//   }
//   else {
//     return 0;
//   } 
// }


function make_tree(n_array){
   root = new tree_node(n_array); 
}


$("#btn_sort").on('click', ()=>{
    sort(numbers_array,0,numbers_array.length-1,"0"); //Object.assign([],numbers_array)
  })


function shuffle(n_array){
  // пока длинна временного массива больше 1
  if (n_array.length-1>1){
    // получаем случайное число от 1 до последнего индекса массива цифр
    let z = Math.floor(Math.random()*(n_array.length-1))
    // меняем местами цифры между последней позицией и позицией z
    n_array[z] = numbers_array[n_array.length-1]
    numbers_array[n_array.length-1] = numbers_array[z];
    numbers_array[z] = n_array[z];
    // убираем последнюю позицию из временного массива
    n_array.pop();
    // передаем в рекурсию
    shuffle(n_array);
  }
  else{
    // если временный массив - одна цифра, выходим из рекурсии
    return 0;
  }
}


// function sort(n_array, start_point, end_point, branch){
//   //merge sort 
  
//   alert("branch: "+branch +"\r\n"+ " <"+ n_array+ ">"+"\r\n" +" start pos: " + (start_point+1) +" end pos: "+ (end_point+1))

//    if (start_point < end_point){
//      let middle = Math.floor((start_point + end_point)/2);
//      //alert(x);
//      let left_n_arr = Object.assign([],n_array).slice(0, middle);
//      sort(left_n_arr , 0, middle, "left" );
//      //alert("out")  
//     let right_n_arr =Object.assign([],n_array).slice(middle);
//      return sort(right_n_arr= n_array.slice(middle+1, end_point) , middle+1, end_point, "right" );
    
//    }
//    else {
//      aaa +=' : '+ n_array[0];
//      c++;
//      return n_array;
//    }  
// }

function new_numbers(){
  for (let i = 0; i<count; i++){
    let a = $("<td class='cell border' id='n"+i+"'></td>").text(numbers_array[i]);
    $("#numbers").append(a);
    $("#buffer").append("<td class='cell border' id='b"+i+"'></td>");
  }
}


</script>

</HTML>